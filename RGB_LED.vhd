-- WARNING: Do NOT edit the input and output ports in this file in a text
-- editor if you plan to continue editing the block that represents it in
-- the Block Editor! File corruption is VERY likely to occur.

-- Copyright (C) 2018  Intel Corporation. All rights reserved.
-- Your use of Intel Corporation's design tools, logic functions
-- and other software and tools, and its AMPP partner logic
-- functions, and any output files from any of the foregoing
-- (including device programming or simulation files), and any
-- associated documentation or information are expressly subject
-- to the terms and conditions of the Intel Program License
-- Subscription Agreement, the Intel Quartus Prime License Agreement,
-- the Intel FPGA IP License Agreement, or other applicable license
-- agreement, including, without limitation, that your use is for
-- the sole purpose of programming logic devices manufactured by
-- Intel and sold by Intel or its authorized distributors.  Please
-- refer to the applicable agreement for further details.


-- Generated by Quartus Prime Version 18.1 (Build Build 625 09/12/2018)
-- Created on Fri Feb 04 15:06:25 2022

LIBRARY ieee;
USE ieee.std_logic_1164.all;
use ieee.numeric_std.all;


--  Entity Declaration

ENTITY RGB_LED IS
	-- {{ALTERA_IO_BEGIN}} DO NOT REMOVE THIS LINE!
	GENERIC
    (
        number_of_LEDs : integer :=4;
        long_timing : INTEGER := 40;
        short_timing : INTEGER := 15;
        bit_counter_max : INTEGER := 23;
        delay_max : INTEGER := 14000
    );
	PORT
	(
		i_clk : IN STD_LOGIC;
		button_0 : IN STD_LOGIC;
        i_led_data : IN STD_LOGIC_VECTOR (0 to bit_counter_max);
        o_data : OUT STD_LOGIC;
        feedback_ready : OUT STD_LOGIC
	);
	-- {{ALTERA_IO_END}} DO NOT REMOVE THIS LINE!

END RGB_LED;


--  Architecture Body

ARCHITECTURE RGB_LED_architecture OF RGB_LED IS

type led_st_type is (st_idle, st_read_bit, st_send_1, st_send_0, st_bits_count, st_led_count, st_rst_delay);
signal led_st: led_st_type := st_idle;

signal long_delay : integer range 0 to long_timing :=0;
signal short_delay : integer range 0 to short_timing :=0;
signal bit_counter : integer range 0 to bit_counter_max :=0;
signal reset_delay : integer range 0 to delay_max := 0;
signal count_led : integer range 0 to number_of_LEDs := 0;

BEGIN
    logic:process(i_clk,button_0)
    begin

        if button_0 = '0' then
            o_data <= '0';
            long_delay<=0;
            short_delay<=0;
            reset_delay<=0;
            bit_counter<=0;
            count_led <=0;

        elsif rising_edge(i_clk) then
            case led_st is
                when st_idle =>
                    o_data <= '0';
                    bit_counter <= 0;
                    reset_delay<=0;
                    feedback_ready <= '1';
                    led_st <= st_read_bit;
                
                when st_read_bit =>
                    feedback_ready <= '0';
                    if i_led_data(bit_counter) = '1' then
                        led_st <= st_send_1;
                    else
                        led_st <= st_send_0;
                    end if;
                
                when st_send_1 =>
                    if long_delay < long_timing then
                        long_delay <= long_delay+1;
                        o_data <= '1';
                    elsif short_delay < short_timing then
                        short_delay <= short_delay+1;
                        o_data <= '0';
                    else
                        long_delay <= 0;
                        short_delay <= 0;
                        led_st <= st_bits_count;
                    end if;

                when st_send_0 =>
                    if short_delay < short_timing then
                        short_delay <= short_delay+1;
                        o_data <= '1';    
                    elsif long_delay < long_timing then
                        long_delay <= long_delay+1;
                        o_data <= '0';
                    else
                        long_delay <= 0;
                        short_delay <= 0;
                        led_st <= st_bits_count;
                    end if;
                
                when st_bits_count =>
                    if bit_counter < bit_counter_max then
                        bit_counter <= bit_counter+1;
                        led_st <= st_read_bit;
                    else
                        bit_counter <= 0;
                        led_st <= st_led_count;
                    end if;
                
                when st_led_count =>
                    if count_led = number_of_LEDs-1 then
                        led_st <= st_rst_delay;
                    else 
                        count_led <= count_led+1;
                        led_st <= st_idle;
                    end if;

                when st_rst_delay =>
                    if reset_delay < delay_max then
                        reset_delay <= reset_delay+1;
                    else
                        count_led <= 0;
                        reset_delay <= 0;
                        led_st <= st_idle;
                    end if;

                when others =>

            end case;
        end if;
    end process;
END RGB_LED_architecture;